# MIYABI 開発フローマップ

## 序文

このドキュメントは、MIYABIエンジンの開発を体系的かつ段階的に進めるための具体的な作業手順（フローマップ）を定義します。場当たり的な開発を避け、一貫した方針でマイルストーンを達成することを目的とします。

## フェーズ1: FFIブリッジとデータ構造の磐石化 (Foundation)

このフェーズの目標は、RustとC++間のデータ交換をゼロコピーかつ完全に安全に行うための揺ぎない基盤を築くことです。これが完了するまで、他の機能開発（ゲームロジック、UI）は行いません。

-   [x] **タスク1.1: FFIデータ構造の定義と共有 (Memory Symmetry)**
    -   [x] `logic`クレートに、`#[repr(C)]`を付与した基本的な描画プリミティブ用の構造体を定義する (例: `Position`, `Color`, `RenderableTriangle`)。
    -   [x] `core`側のC++コードで、Rustと全く同じメモリレイアウトを持つ構造体を定義する。
    -   [x] `cxx`ブリッジを更新し、これらの構造体のスライス (`&[T]`) をRustからC++へゼロコピーで渡せることを確認する関数を実装する。
    -   [x] 簡単なテストシーンをRustで構築し、C++側で受け取ったデータ（例: 三角形の頂点座標）が正しいことをログ出力で検証する。

-   [x] **タスク1.2: 描画コマンドバッファの確立**
    -   [x] Rust側に、描画コマンド（例: `enum RenderCommand { DrawTriangles(Vec<RenderableTriangle>), ... }`）を定義する。
    -   [x] `cxx`ブリッジを介して、このコマンドバッファ（`Vec<RenderCommand>`に相当するデータ）をフレームごとにC++へ渡す機構を実装する。
    -   [x] C++のレンダラを「ステートレス」にリファクタリングする。C++側は状態を持たず、受け取ったコマンドバッファを解釈して描画するだけの責務に限定する。

## フェーズ2: レンダリングパイプラインの拡張

基盤が固まったら、表現力を向上させるためにレンダリング機能を拡張します。

-   [x] **タスク2.1: 基本的なシェーダとマテリアルの導入**
    -   [x] Rust側でマテリアル情報を定義できるようにする（`RenderableObject`に`material_id`を追加）。
    -   [x] C++側で`ShaderManager`, `MeshManager`, `MaterialManager`を導入し、`material_id`に基づいて描画リソースを管理する基盤を実装。
    -   [x] 効率的なインスタンスレンダリングに対応した、単純な単色シェーダを実装。
    -   [x] テクスチャマッピング用のシェーダを実装する。

-   [x] **タスク2.2: テクスチャの読み込みと管理**
    -   [x] (Next) Rust側からテクスチャのロードを指示するコマンドを定義する。
    -   [x] C++側で、画像ファイル（PNGなど）を読み込み、OpenGLのテクスチャオブジェクトとしてGPUにアップロードする機構を実装する。
    -   [x] RustはテクスチャIDを通じて描画を指示できるようにする。

## フェーズ3: ゲームロジックとインタラクション

基本的な描画が可能になったところで、ゲームのロジックを実装します。

-   [x] **タスク3.1: ECSの高度化とシーン構築API**
    -   [x] `PLAN.md`にある宣言的シーンマクロのアイデアを具体化し、`world.spawn()`のようなAPIを整備する。
    -   [x] 位置や速度といった基本的なコンポーネントを更新する簡単なシステム（System）をRustで記述する。
    -   [x] フレームごとにRustの`world.update()`のような関数を呼び出し、C++へ描画データを渡すメインループを完成させる。

-   [ ] **タスク3.2: 入力処理**
    -   [ ] C++(GLFW)側でキーボードやマウスの入力を検知する。
    -   [ ] 入力状態をまとめた構造体を定義し、毎フレームRustへ渡す。
    -   [ ] Rustのシステムが入力に応じてエンティティの状態を変化させる（例: キー入力で三角形が動く）ロジックを実装する。

## フェーズ4: UIとテキスト描画

2Dの会話劇という目標に向け、UI機能を追加します。

-   [ ] **タスク4.1: フォントの読み込みとグリフの生成**
    -   [ ] C++側でFreeTypeなどのライブラリを導入し、TrueTypeフォント（.ttf）を読み込めるようにする。
    -   [ ] 文字からビットマップ（テクスチャアトラス）を生成する機構を実装する。

-   [ ] **タ.2: テキスト描画パイプライン**
    -   [ ] Rust側から描画したい文字列、位置、フォントサイズなどを指定するUIコマンドを定義する。
    -   [ ] C++側で、UIコマンドとグリフのテクスチャアトラスを使って、画面上にテキストを描画する。