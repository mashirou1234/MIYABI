# MIYABI 開発フローマップ

## 序文

このドキュメントは、MIYABIエンジンの開発を体系的かつ段階的に進めるための具体的な作業手順（フローマップ）を定義します。場当たり的な開発を避け、一貫した方針でマイルストーンを達成することを目的とします。

## 目的との対応付け（2026-02-23追記）

本ファイルは「作業タスク管理」を目的とする。  
到達判定は、コア開発とゲーム開発で分離して管理する。

- コア到達判定（成果物・DoD）: `docs/CORE_DEVELOPMENT_TRACK.md`
- ゲーム到達判定（成果物・DoD）: `docs/GAME_DEVELOPMENT_TRACK.md`
- 作業タスク（実装順）: `PLAN.md`
- スレッド単位の変更履歴: `docs/CODEX_MIGRATION_STATUS.md`

## フェーズ1: FFIブリッジとデータ構造の磐石化 (Foundation)

このフェーズの目標は、RustとC++間のデータ交換をゼロコピーかつ完全に安全に行うための揺ぎない基盤を築くことです。これが完了するまで、他の機能開発（ゲームロジック、UI）は行いません。

-   [x] **タスク1.1: FFIデータ構造の定義と共有 (Memory Symmetry)**
    -   [x] `logic`クレートに、`#[repr(C)]`を付与した基本的な描画プリミティブ用の構造体を定義する (例: `Position`, `Color`, `RenderableTriangle`)。
    -   [x] `core`側のC++コードで、Rustと全く同じメモリレイアウトを持つ構造体を定義する。
    -   [x] `cxx`ブリッジを更新し、これらの構造体のスライス (`&[T]`) をRustからC++へゼロコピーで渡せることを確認する関数を実装する。
    -   [x] 簡単なテストシーンをRustで構築し、C++側で受け取ったデータ（例: 三角形の頂点座標）が正しいことをログ出力で検証する。

-   [x] **タスク1.2: 描画コマンドバッファの確立**
    -   [x] Rust側に、描画コマンド（例: `enum RenderCommand { DrawTriangles(Vec<RenderableTriangle>), ... }`）を定義する。
    -   [x] `cxx`ブリッジを介して、このコマンドバッファ（`Vec<RenderCommand>`に相当するデータ）をフレームごとにC++へ渡す機構を実装する。
    -   [x] C++のレンダラを「ステートレス」にリファクタリングする。C++側は状態を持たず、受け取ったコマンドバッファを解釈して描画するだけの責務に限定する。

## フェーズ2: レンダリングパイプラインの拡張

基盤が固まったら、表現力を向上させるためにレンダリング機能を拡張します。

-   [x] **タスク2.1: 基本的なシェーダとマテリアルの導入**
    -   [x] Rust側でマテリアル情報を定義できるようにする（`RenderableObject`に`material_id`を追加）。
    -   [x] C++側で`ShaderManager`, `MeshManager`, `MaterialManager`を導入し、`material_id`に基づいて描画リソースを管理する基盤を実装。
    -   [x] 効率的なインスタンスレンダリングに対応した、単純な単色シェーダを実装。
    -   [x] テクスチャマッピング用のシェーダを実装する。

-   [x] **タスク2.2: テクスチャの読み込みと管理**
    -   [x] Rust側からテクスチャのロードを指示するコマンドを定義する。
    -   [x] C++側で、画像ファイル（PNGなど）を読み込み、OpenGLのテクスチャオブジェクトとしてGPUにアップロードする機構を実装する。
    -   [x] RustはテクスチャIDを通じて描画を指示できるようにする。

## フェーズ3: ゲームロジックとインタラクション

基本的な描画が可能になったところで、ゲームのロジックを実装します。

-   [x] **タスク3.1: ECSの高度化とシーン構築API**
    -   [x] `PLAN.md`にある宣言的シーンマクロのアイデアを具体化し、`world.spawn()`のようなAPIを整備する。
    -   [x] 位置や速度といった基本的なコンポーネントを更新する簡単なシステム（System）をRustで記述する。
    -   [x] フレームごとにRustの`world.update()`のような関数を呼び出し、C++へ描画データを渡すメインループを完成させる。

-   [x] **タスク3.2: 入力処理**
    -   [x] C++(GLFW)側でキーボードやマウスの入力を検知する。
    -   [x] 入力状態をまとめた構造体を定義し、毎フレームRustへ渡す。
    -   [x] Rustのシステムが入力に応じてエンティティの状態を変化させる（例: キー入力で三角形が動く）ロジックを実装する。

## フェーズ4: UIとテキスト描画

2Dの会話劇という目標に向け、UI機能を追加します。

-   [x] **タスク4.1: フォントの読み込みとグリフの生成**
    -   [x] C++側でFreeTypeなどのライブラリを導入し、TrueTypeフォント（.ttf）を読み込めるようにする。
    -   [x] 文字からビットマップ（テクスチャアトラス）を生成する機構を実装する。

-   [x] **タスク4.2: テキスト描画パイプライン**
    -   [x] Rust側から描画したい文字列、位置、フォントサイズなどを指定するUIコマンドを定義する。
    -   [x] C++側で、UIコマンドとグリフのテクスチャアトラスを使って、画面上にテキストを描画する。

## フェーズ5: SDK化とプロジェクトの分離 (SDK-ification)

現在のエンジン開発環境から、ゲーム開発者が利用するための「SDK」を分離し、より再利用性の高い構成を目指します。

-   [x] **タスク5.1: ゲームプロジェクトの分離**
    -   [x] `logic` クレートからゲーム固有のロジックを分離し、`sample_game` のような新しいディレクトリに移動する。
    -   [x] CMakeの構成を修正し、`core`（エンジン）をライブラリとしてビルドし、`sample_game` がそのライブラリをリンクする形に変更する。これにより、エンジンとゲームの依存関係を明確にする。

-   [x] **タスク5.2: SDKビルドプロセスの構築**
    -   [x] `sdk` ディレクトリを生成するためのビルドスクリプト（CMakeまたはシェルスクリプト）を作成する。
    -   [x] スクリプトは、リリースモードでエンジンライブラリをビルドし、必要なファイル（ライブラリ、公開ヘッダー、テンプレート）を `sdk` ディレクトリにコピーする機能を持つ。
    -   [x] 最終的に `sdk` ディレクトリをzipで圧縮し、配布可能なパッケージを生成する。

## フェーズ6: ゲームステート管理 (In-Game/Out-of-Game)

タイトル画面、ゲーム中、ポーズ画面といった、ゲームの基本的な流れ（シーケンス）を管理する仕組みを導入します。

-   [x] **タスク6.1: ゲームステートマシンの導入**
    -   [x] Rust側に、ゲームの状態（例: `MainMenu`, `InGame`, `Paused`）を管理するためのステートマシンを実装する。
    -   [x] メインループは、現在のステートに応じた更新処理・描画処理を呼び出すように変更する。

-   [x] **タスク6.2: UIシステムの基礎とメインメニュー作成**
    -   [x] クリック可能な `Button` コンポーネントをRustで定義する（当たり判定、コールバック機能を含む）。
    -   [x] 新しいUIシステムとステートマシンを使い、ゲームの入り口となる「メインメニュー」画面を実装する。「ゲーム開始」ボタンを押すと `InGame` ステートに遷移するなど。

## フェーズ7: オーディオ基盤の実装 (Audio Backend)

まずはOSとの差異を吸収する安定的なオーディオ出力の土台を築きます。

-   [x] **タスク7.1: オーディオバックエンドの統合**
    -   [x] C++側に `miniaudio` をサードパーティライブラリとして統合する。
    -   [x] `miniaudio` を利用し、単純な音声ファイル（.wav）を再生する最小限のテストコードをC++側に実装する。
    -   [x] Rust側からこの再生機能を呼び出すための一時的なFFIを定義する（このFFIはフェーズ8で破棄・高度化される前提）。

## フェーズ8: 物理演算と当たり判定

ゲームのインタラクションを豊かにするための物理演算の基礎を実装します。

-   [x] **タスク8.1: 2D当たり判定システムの実装**
    -   [x] エンティティの領域を示す `Collider` コンポーネント（例: AABB矩形）をRustで定義する。
    -   [x] `Collider` 同士の衝突を検知し、衝突イベント（`CollisionEvent`）を発生させる `PhysicsSystem` を実装する。

## フェーズ9: 2D縦切り（Vertical Slice）完成

`docs/GAME_DEVELOPMENT_TRACK.md` の G0〜G3 に対応。  
「30分遊べる2Dゲーム1本」を完成させ、実運用上の欠陥を洗い出す。

-   [x] **タスク9.1: 縦切り仕様の固定**
    -   [x] 仕様書を作成し、勝敗条件・ゲームループ・遷移条件を確定する。
    -   [x] 必須シーン（タイトル/ゲーム本編/リザルト）とUI遷移を確定する。
    -   [x] 最小セーブデータ仕様（進行、設定）を確定する。

-   [x] **タスク9.2: ゲームプレイループの完成**
    -   [x] プレイヤー制御、敵/障害物、当たり判定、リトライ導線を実装する。
    -   [x] BGM/SEを状態遷移に連動させる。
    -   [x] ゲームオーバー/クリア時のリザルト遷移を実装する。

-   [ ] **タスク9.3: 配布可能ビルドの成立（1OS）**
    -   [ ] 配布ビルド手順を固定し、手順書を作成する。
    -   [ ] クリーン環境で再現ビルドを確認する。

**DoD (Phase 9):**
-   [ ] 30分連続プレイで進行不能・クラッシュが発生しない。
-   [ ] 初回起動から終了までの導線が1本に繋がっている。
-   [ ] 配布手順が第三者に再現可能。

## フェーズ10: 2Dプロダクション基盤化

`docs/CORE_DEVELOPMENT_TRACK.md` の C1 に対応。  
2Dタイトルを継続開発できる状態へ移行する。

-   [ ] **タスク10.1: 2D制作必須機能の拡充**
    -   [ ] スプライトアニメーション（再生、遷移、速度制御）を実装する。
    -   [ ] タイルマップ/レベルデータ読込を実装する。
    -   [ ] 入力マッピング（キーバインド）を実装する。

-   [ ] **タスク10.2: アセットパイプライン**
    -   [x] コア Save サブシステムを定義する（JSON envelope / バージョン / 破損バックアップ / 原子的保存）。
    -   [x] セーブ/ロード最小実装をプレイ導線へ統合する（起動時ロード / リザルト遷移時保存 / 終了時保存）。
    -   [x] 設定UIを実装し、設定変更時の保存フックを接続する。
    -   [x] 設定値のランタイム適用（音量反映 / fullscreen 切替）を接続する。
    -   [x] BGM実再生導線を接続し、`bgm_volume` がランタイム反映されるようにする。
    -   [x] import/reimport 手順を確立する。
    -   [x] アセットID管理と参照整合チェックを導入する。
    -   [x] 失敗時の診断ログと復旧手順を整備する。

-   [ ] **タスク10.3: 品質基盤**
    -   [x] CIで `configure/build/smoke` を自動実行する。
    -   [ ] 性能ベースラインを確立し、回帰検知を導入する。
    -   [ ] クラッシュ/不具合報告テンプレートを整備する。

**DoD (Phase 10):**
-   [ ] 外部サンプル2本以上で再利用できる。
-   [ ] リリース作業がドキュメント化され、再現できる。
-   [ ] 性能回帰を定量的に検知できる。

## フェーズ11: 3D基盤の導入

`docs/CORE_DEVELOPMENT_TRACK.md` の C2 に対応。  
既存2D基盤を壊さずに3Dレンダリングの土台を追加する。

-   [ ] **タスク11.1: 3D描画パイプライン最小構築**
    -   [ ] 透視投影カメラとビュー行列更新を実装する。
    -   [ ] 深度テストを導入し、3Dオブジェクトの前後関係を正しく描画する。
    -   [ ] 3Dメッシュ読込（最小1フォーマット）を実装する。

-   [ ] **タスク11.2: 3Dシーンデータモデル**
    -   [ ] Transform（位置/回転/スケール）を3D前提で統一する。
    -   [ ] 3D用Renderable定義を整理し、2Dと共存可能にする。
    -   [ ] ライト情報（最小: directional 1灯）を導入する。

-   [ ] **タスク11.3: 互換性維持**
    -   [ ] 2D既存シーンが破壊されていないことを回帰テストで確認する。
    -   [ ] 2D/3D切替時の状態遷移不整合を解消する。

**DoD (Phase 11):**
-   [ ] 3D空間で複数オブジェクトを表示できる。
-   [ ] 2D機能が既存どおり動作する。

## フェーズ12: 3D縦切り（Vertical Slice）完成

`docs/GAME_DEVELOPMENT_TRACK.md` の G4 に対応。  
3Dゲーム最小ループを実運用可能な形で成立させる。

-   [ ] **タスク12.1: 3Dプレイアブルループ**
    -   [ ] 3D移動、カメラ操作、インタラクションを実装する。
    -   [ ] 3D当たり判定/衝突応答（または同等代替）を実装する。
    -   [ ] 3D向けUIオーバーレイを実装する。

-   [ ] **タスク12.2: 3Dアセット運用**
    -   [ ] メッシュ/テクスチャ/マテリアルの読み込み導線を整備する。
    -   [ ] 3Dサンプルシーンを作成し、実行確認する。

**DoD (Phase 12):**
-   [ ] 3D縦切りデモ1本を完成し、開始から終了まで通せる。
-   [ ] 既知の致命的不具合がない。

## フェーズ13: 3Dプロダクション基盤化

`docs/CORE_DEVELOPMENT_TRACK.md` の C3 に対応。  
3Dタイトルを継続開発できる状態へ移行する。

-   [ ] **タスク13.1: 表現機能の拡張**
    -   [ ] マテリアル/ライティングを拡張する（複数ライト、基本陰影）。
    -   [ ] アニメーション再生を実装する（最小: クリップ再生）。
    -   [ ] シーン管理（ロード/アンロード）を実装する。

-   [ ] **タスク13.2: 性能最適化**
    -   [ ] カリング（視錐台など）を導入する。
    -   [ ] 描画バッチ最適化とメモリ監視を導入する。
    -   [ ] 代表シーンでベースラインを記録する。

-   [ ] **タスク13.3: ツール最小セット**
    -   [ ] レベル/シーン編集の補助ツールを提供する。
    -   [ ] アセット検証ツールを提供する。

**DoD (Phase 13):**
-   [ ] 中規模3Dサンプルが安定動作する。
-   [ ] 開発中の性能ボトルネックを継続監視できる。

## フェーズ14: エコシステム競争力強化

`docs/CORE_DEVELOPMENT_TRACK.md` の C4 に対応。  
商用エンジン群と比較可能な「開発体験」を整備する。

-   [ ] **タスク14.1: 開発体験の拡張**
    -   [ ] デバッグ可視化（統計、描画/物理デバッグ表示）を強化する。
    -   [ ] 拡張機構（プラグイン/モジュール方針）を定義する。
    -   [ ] ドキュメント体系（チュートリアル/API/運用）を整備する。

-   [ ] **タスク14.2: プラットフォームと運用**
    -   [ ] 対応プラットフォームを段階的に拡大する。
    -   [ ] CI/CD とリリース運用を確立する。
    -   [ ] 互換性方針（SDK/ABI/マイグレーション）を定義する。

**DoD (Phase 14):**
-   [ ] 新規開発者がドキュメントのみで初期開発を開始できる。
-   [ ] 複数プラットフォームで継続的にビルド/検証できる。
-   [ ] バージョン更新時の移行手順が定義されている。
