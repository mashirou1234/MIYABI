# MIYABI 開発フローマップ

## 序文

このドキュメントは、MIYABIエンジンの開発を体系的かつ段階的に進めるための具体的な作業手順（フローマップ）を定義します。場当たり的な開発を避け、一貫した方針でマイルストーンを達成することを目的とします。

## フェーズ1: FFIブリッジとデータ構造の磐石化 (Foundation)

このフェーズの目標は、RustとC++間のデータ交換をゼロコピーかつ完全に安全に行うための揺ぎない基盤を築くことです。これが完了するまで、他の機能開発（ゲームロジック、UI）は行いません。

-   [x] **タスク1.1: FFIデータ構造の定義と共有 (Memory Symmetry)**
    -   [x] `logic`クレートに、`#[repr(C)]`を付与した基本的な描画プリミティブ用の構造体を定義する (例: `Position`, `Color`, `RenderableTriangle`)。
    -   [x] `core`側のC++コードで、Rustと全く同じメモリレイアウトを持つ構造体を定義する。
    -   [x] `cxx`ブリッジを更新し、これらの構造体のスライス (`&[T]`) をRustからC++へゼロコピーで渡せることを確認する関数を実装する。
    -   [x] 簡単なテストシーンをRustで構築し、C++側で受け取ったデータ（例: 三角形の頂点座標）が正しいことをログ出力で検証する。

-   [x] **タスク1.2: 描画コマンドバッファの確立**
    -   [x] Rust側に、描画コマンド（例: `enum RenderCommand { DrawTriangles(Vec<RenderableTriangle>), ... }`）を定義する。
    -   [x] `cxx`ブリッジを介して、このコマンドバッファ（`Vec<RenderCommand>`に相当するデータ）をフレームごとにC++へ渡す機構を実装する。
    -   [x] C++のレンダラを「ステートレス」にリファクタリングする。C++側は状態を持たず、受け取ったコマンドバッファを解釈して描画するだけの責務に限定する。

## フェーズ2: レンダリングパイプラインの拡張

基盤が固まったら、表現力を向上させるためにレンダリング機能を拡張します。

-   [x] **タスク2.1: 基本的なシェーダとマテリアルの導入**
    -   [x] Rust側でマテリアル情報を定義できるようにする（`RenderableObject`に`material_id`を追加）。
    -   [x] C++側で`ShaderManager`, `MeshManager`, `MaterialManager`を導入し、`material_id`に基づいて描画リソースを管理する基盤を実装。
    -   [x] 効率的なインスタンスレンダリングに対応した、単純な単色シェーダを実装。
    -   [x] テクスチャマッピング用のシェーダを実装する。

-   [x] **タスク2.2: テクスチャの読み込みと管理**
    -   [x] Rust側からテクスチャのロードを指示するコマンドを定義する。
    -   [x] C++側で、画像ファイル（PNGなど）を読み込み、OpenGLのテクスチャオブジェクトとしてGPUにアップロードする機構を実装する。
    -   [x] RustはテクスチャIDを通じて描画を指示できるようにする。

## フェーズ3: ゲームロジックとインタラクション

基本的な描画が可能になったところで、ゲームのロジックを実装します。

-   [x] **タスク3.1: ECSの高度化とシーン構築API**
    -   [x] `PLAN.md`にある宣言的シーンマクロのアイデアを具体化し、`world.spawn()`のようなAPIを整備する。
    -   [x] 位置や速度といった基本的なコンポーネントを更新する簡単なシステム（System）をRustで記述する。
    -   [x] フレームごとにRustの`world.update()`のような関数を呼び出し、C++へ描画データを渡すメインループを完成させる。

-   [x] **タスク3.2: 入力処理**
    -   [x] C++(GLFW)側でキーボードやマウスの入力を検知する。
    -   [x] 入力状態をまとめた構造体を定義し、毎フレームRustへ渡す。
    -   [x] Rustのシステムが入力に応じてエンティティの状態を変化させる（例: キー入力で三角形が動く）ロジックを実装する。

## フェーズ4: UIとテキスト描画

2Dの会話劇という目標に向け、UI機能を追加します。

-   [x] **タスク4.1: フォントの読み込みとグリフの生成**
    -   [x] C++側でFreeTypeなどのライブラリを導入し、TrueTypeフォント（.ttf）を読み込めるようにする。
    -   [x] 文字からビットマップ（テクスチャアトラス）を生成する機構を実装する。

-   [x] **タスク4.2: テキスト描画パイプライン**
    -   [x] Rust側から描画したい文字列、位置、フォントサイズなどを指定するUIコマンドを定義する。
    -   [x] C++側で、UIコマンドとグリフのテクスチャアトラスを使って、画面上にテキストを描画する。

## フェーズ5: SDK化とプロジェクトの分離 (SDK-ification)

現在のエンジン開発環境から、ゲーム開発者が利用するための「SDK」を分離し、より再利用性の高い構成を目指します。

-   [x] **タスク5.1: ゲームプロジェクトの分離**
    -   [x] `logic` クレートからゲーム固有のロジックを分離し、`sample_game` のような新しいディレクトリに移動する。
    -   [x] CMakeの構成を修正し、`core`（エンジン）をライブラリとしてビルドし、`sample_game` がそのライブラリをリンクする形に変更する。これにより、エンジンとゲームの依存関係を明確にする。

-   [x] **タスク5.2: SDKビルドプロセスの構築**
    -   [x] `sdk` ディレクトリを生成するためのビルドスクリプト（CMakeまたはシェルスクリプト）を作成する。
    -   [x] スクリプトは、リリースモードでエンジンライブラリをビルドし、必要なファイル（ライブラリ、公開ヘッダー、テンプレート）を `sdk` ディレクトリにコピーする機能を持つ。
    -   [x] 最終的に `sdk` ディレクトリをzipで圧縮し、配布可能なパッケージを生成する。

## フェーズ6: ゲームステート管理 (In-Game/Out-of-Game)

タイトル画面、ゲーム中、ポーズ画面といった、ゲームの基本的な流れ（シーケンス）を管理する仕組みを導入します。

-   [x] **タスク6.1: ゲームステートマシンの導入**
    -   [x] Rust側に、ゲームの状態（例: `MainMenu`, `InGame`, `Paused`）を管理するためのステートマシンを実装する。
    -   [x] メインループは、現在のステートに応じた更新処理・描画処理を呼び出すように変更する。

-   [x] **タスク6.2: UIシステムの基礎とメインメニュー作成**
    -   [x] クリック可能な `Button` コンポーネントをRustで定義する（当たり判定、コールバック機能を含む）。
    -   [x] 新しいUIシステムとステートマシンを使い、ゲームの入り口となる「メインメニュー」画面を実装する。「ゲーム開始」ボタンを押すと `InGame` ステートに遷移するなど。

## フェーズ7: オーディオ基盤の実装 (Audio Backend)

まずはOSとの差異を吸収する安定的なオーディオ出力の土台を築きます。

-   [x] **タスク7.1: オーディオバックエンドの統合**
    -   [x] C++側に `miniaudio` をサードパーティライブラリとして統合する。
    -   [x] `miniaudio` を利用し、単純な音声ファイル（.wav）を再生する最小限のテストコードをC++側に実装する。
    -   [x] Rust側からこの再生機能を呼び出すための一時的なFFIを定義する（このFFIはフェーズ8で破棄・高度化される前提）。

## フェーズ8: 物理演算と当たり判定

ゲームのインタラクションを豊かにするための物理演算の基礎を実装します。

-   [ ] **タスク8.1: 2D当たり判定システムの実装**
    -   [ ] エンティティの領域を示す `Collider` コンポーネント（例: AABB矩形）をRustで定義する。
    -   [ ] `Collider` 同士の衝突を検知し、衝突イベント（`CollisionEvent`）を発生させる `PhysicsSystem` を実装する。

## 長期的な展望 (Beyond Phase 8)

フェーズ8完了後のMIYABIエンジンは、基本的な2Dゲームを開発するための堅牢な基盤を持つことになります。その先の目標として、以下を掲げます。

**目標: 「MIYABI SDKを使い、小規模ながらも完成された2Dゲームを一本制作する」**

このプロセス（ドッグフーディング）を通じて、エンジンに本当に必要とされる、以下のようなより高度な機能を特定し、実装していきます。

*   **プロフェッショナルなオーディオスタック:**
    *   **エンジン層:** C++で独自のオーディオエンジン（ミキサー、3Dポジショニング、エフェクトチェーンの基盤）を構築し、BGM/SE/Voiceなどのバス（Bus）構造を導入して柔軟なミキシングを可能にする。
    *   **インターフェース層:** Rustからは`play_sound("explosion_1")`のような抽象的なイベント名で再生を指示。実際の音声ファイルパスや再生設定（音量、ピッチなど）は、外部の定義ファイル（例: `sounds.toml`）で管理し、C++エンジンがそれを解釈して再生する。
*   **アニメーションシステム:** スプライトシートやスケルタルアニメーションへの対応。
*   **洗練されたUI/UX:** ゲームパッド対応の改善、ローカライズ、画面遷移のエフェクトなど。
*   **パフォーマンス最適化:** 実際のゲーム開発でボトルネックとなる箇所の特定と改善。
*   **エディタとツール:** 開発効率を向上させるためのシンプルな外部ツール（レベルエディタなど）。

自らエンジンの最初の利用者となることで、MIYABIを真に実践的な汎用2Dゲームエンジンへと昇華させていくことを目指します。