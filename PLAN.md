# MIYABI：Code-as-Scene 構築計画書

## 1. ミッション・ステートメント

「宮大工の精神」に基づき、Rust（頭脳・安全性）とC++（筋肉・速度）を高度に分離・融合させたゲームエンジン「MIYABI」を開発する。すべてのシーン、ロジック、オブジェクトは「エレガントなコード」によって定義される。

## 2. コア原則と制約事項

- **Code-as-Scene:** GUIエディタは不要。すべてはコードで完結し、バージョン管理（Git）に完全に馴染む形式であること。
- **純粋なステートレス・レンダラ:** C++側は「何を描画するか」を知らず、Rustから渡された「描画命令リスト」を解釈して実行するだけの役割に徹する。
- **Safety First:** Rustの所有権モデルと型システムをFFI境界を越えて適用し、C++側のメモリ安全性を確保する。

## 3. 開発ロードマップ

### フェーズ1: 基盤構築

- [x] **High: Archetype ECS**
  - 同じコンポーネント構成を持つエンティティ群をメモリ上に連続配置し、キャッシュ効率を最大化する。
- [x] **High: Command Buffer**
  - 毎フレーム、RustがC++へ送信する「描画命令（Mesh, Transform, Material等）」のキューイング機構を実装する。
- [x] **Med: Hot-Reloadable Logic**
  - Rustのロジックを動的ライブラリ（dylib）として切り出し、実行中に再コンパイル＆リロードする基盤を設計する。
- [ ] **Med: Text/UI Layer**
  - 2Dの会話劇を想定し、Rust側で文字列と演出タイミングを定義し、C++で高精細に描画するアーキテクチャを構築する。

### フェーズ1.5: 技術的急所 (最優先タスク)

- [ ] **A. メモリレイアウトの同期 (Memory Symmetry)**
  - `#[repr(C)]` を活用し、RustコンポーネントとC++構造体のメモリレイアウトを完全に一致させ、ゼロコピーでのデータ共有を実現する。
- [ ] **B. 宣言的シーン・マクロ**
  - Rust側で `world.spawn((...)).build()` のような直感的APIでシーンを構築できるマクロまたはビルダーパターンを設計する。
- [ ] **C. FFIブリッジの洗練**
  - `cxx`を活用し、フレームごとの「描画コマンドバッファ」の受け渡しを自動化・効率化する。

## 4. 完了ログ

- **2026-01-30:** `feat(core, logic): Implement initial scene rendering from Rust data` (Commit: `5b215fc`)
  - (旧アーキテクチャ) Rustで定義されたシーン情報に基づき、C++でレンダリングする基本パイプラインを実装。