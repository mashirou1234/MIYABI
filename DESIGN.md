# MIYABI エンジン設計思想

## 1. コアコンセプト：「コード駆動の美学」 (Code-as-Scene)

MIYABIは、「宮大工」の精神に基づくC++/Rustハイブリッド3Dゲームエンジンです。その核となる思想は「コード駆動 (Code-as-Scene)」です。これは、ゲームの世界、オブジェクト、ロジックそのものを、精緻に作られた工芸品のような、エレガントで明確なコードによって定義するという考え方です。

- **宣言的かつイミュータブルなシーン:** ゲームシーンはRustコード内で宣言的に構築されます。シーンの定義コードそのものが、信頼できる唯一の情報源（Source of Truth）となります。
- **データ駆動型アーキテクチャ:** データ（コンポーネント）とロジック（システム）を分離する、エンティティ・コンポーネント・システム（ECS）パターンを主軸としたデータ駆動型のアプローチを採用します。
- **「頭脳」としてのRust:** Rustは、シーンのロジック、状態管理、ゲーム世界の高レベルな定義を担当します。その安全性とモダンな機能は、堅牢なシステムを構築するのに理想的です。
- **「筋肉」としてのC++:** C++は、グラフィックスAPI（OpenGL/Vulkan等）との連携や、生データのレンダリング処理など、パフォーマンスが最重要となる低レベルなタスクを管理します。

## 2. アーキテクチャ目標

- **明確なC++/Rust境界:** C++とRust間のインターフェース（ブリッジ）は、最小限かつ明確に定義されている必要があります。安全で明確な相互運用性のために`cxx`を使用します。
- **パフォーマンス:** レンダリングのようなクリティカルなループはC++側で最適化し、Rust側で準備されたデータを効率的に処理します。
- **ホットリロード（将来的な目標）:** 「Code-as-Scene」のコンセプトは、強力な開発ワークフローへの扉を開きます。例えば、C++アプリケーションの実行中に、Rustのロジッククレートを動的に再コンパイルし、リロードする、といった機能です。

## 3. 詳細アーキテクチャ (Detailed Architecture)

「コード駆動の美学」を実現するため、MIYABIは以下のコンポーネントで構成されます。

### 3.1. エンジンの中核 (Core Engine) - C++

C++層はOSおよびGPUと直接対話し、パフォーマンスが最重要視される低レベルな処理を担当する「筋肉」です。

-   **レンダリングバックエンド:**
    -   **役割:** Rustから送られてきた描画コマンドバッファを解釈し、OpenGL/Vulkan/Metal等のグラフィクスAPIを叩いて実際に描画します。
    -   **実装:** レンダラは完全にステートレスであり、フレームごとに受け取るデータにのみ依存します。状態管理（どのシェーダを使うか、どのテクスチャをバインドするか等）はすべてRust側からの指示に従います。
-   **リソースマネージャー:**
    -   **役割:** シェーダ、テクスチャ、フォント、メッシュといったGPUリソースを効率的に管理します。
    -   **実装:** `ShaderManager`, `TextureManager`などが存在し、Rustから送られてくるリソースロード要求（例: `LoadTexture("player.png")`）を処理し、リソースのライフタイムを管理します。Rust側はID（`TextureId`）を通じてリソースを参照します。
-   **ウィンドウおよび入力システム:**
    -   **役割:** GLFW等のライブラリを使用し、ウィンドウの生成、管理、およびキーボード、マウスからの入力を受け付けます。
    -   **実装:** OSからの入力イベントは、毎フレーム固定長のデータ構造にまとめられ、FFIブリッジを通じてRustへ送られます。

### 3.2. ゲームの頭脳 (Game Logic) - Rust

Rust層はゲームのロジック、状態、そしてシーン構造全体を管理する「頭脳」です。安全性と表現力を最大限に活用します。

-   **エンティティ・コンポーネント・システム (ECS):**
    -   **役割:** ゲーム世界の構成要素をデータ（コンポーネント）とロジック（システム）に分離します。これにより、柔軟で再利用性の高い、パフォーマンスの良いコードを実現します。
    -   **実装:** `hecs` や `bevy-ecs` のような既存のECSライブラリを採用、もしくは独自のシンプルな実装から開始します。
        -   **Entity:** ゲーム内オブジェクトの一意な識別子。
        -   **Component:** 位置、速度、HPといったデータ。`#[repr(C)]`を付与されたデータ構造が中心となります。
        -   **System:** コンポーネントのデータを更新し、ゲームロジックを実行する関数。例: `fn physics_system(world: &mut World)`。
-   **シーン定義:**
    -   **役割:** 「Code-as-Scene」の核心。Rustのコードで直接ゲームシーンを構築します。
    -   **実装:** 宣言的なマクロやビルダーパターンを用いて、直感的にエンティティとコンポーネントを組み合わせてシーンを生成するAPIを提供します。
        ```rust
        // 将来的な理想像
        scene! {
            world,
            entity player: (
                Transform { position: (0.0, 0.0) },
                Sprite { texture_id: PLAYER_TEXTURE, layer: 1 },
                PlayerController { speed: 100.0 }
            ),
            entity background: (
                Transform { position: (0.0, 0.0) },
                Sprite { texture_id: BG_TEXTURE, layer: 0 }
            )
        };
        ```
-   **ステート管理:**
    -   **役割:** タイトル画面、ゲーム中、ポーズ画面といったゲーム全体のフローを管理します。
    -   **実装:** シンプルなEnumベースのステートマシンを実装し、各ステートで実行される`System`群を切り替えることで実現します。

### 3.3. C++/Rust間のブリッジ (FFI Bridge)

両世界の通信は、`cxx`ライブラリを用いて構築され、厳格なルールに基づきます。

-   **データフロー:**
    -   **Rust -> C++:** 主に描画データ。毎フレーム、Rustのワールド情報から「描画コマンドバッファ」が生成され、C++へゼロコピーで渡されます。これには、オブジェクトのトランスフォーム情報、使用するマテリアルID、テクスチャIDなどが含まれます。
    -   **C++ -> Rust:** 主に入力データ。毎フレーム、C++で収集された入力状態が構造体としてRustへ渡されます。
-   **所有権とライフタイム:**
    -   **原則:** 全てのゲームステートとオブジェクトの所有権はRustが持ちます。C++側は、Rustから貸与されたデータ（スライスや参照）をそのフレーム内で読み取るだけで、データを所有しません。
    -   **例外:** GPUリソース（テクスチャ、メッシュ）の実体はC++側で管理されますが、そのライフタイム（生成・破棄）の指示はRust側から行われます。
